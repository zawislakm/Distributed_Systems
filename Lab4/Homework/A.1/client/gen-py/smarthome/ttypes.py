#
# Autogenerated by Thrift Compiler (0.20.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class InvalidArgumentType(object):
    NOCD = 1
    WRONGDEVICETYPE = 2
    CDALREADYIN = 3
    WRONGRADIOSTATION = 4

    _VALUES_TO_NAMES = {
        1: "NOCD",
        2: "WRONGDEVICETYPE",
        3: "CDALREADYIN",
        4: "WRONGRADIOSTATION",
    }

    _NAMES_TO_VALUES = {
        "NOCD": 1,
        "WRONGDEVICETYPE": 2,
        "CDALREADYIN": 3,
        "WRONGRADIOSTATION": 4,
    }


class EmptyPrinterType(object):
    NOPAPER = 1
    NOCARTRIDGE = 2

    _VALUES_TO_NAMES = {
        1: "NOPAPER",
        2: "NOCARTRIDGE",
    }

    _NAMES_TO_VALUES = {
        "NOPAPER": 1,
        "NOCARTRIDGE": 2,
    }


class SmarthomeDevicesType(object):
    PLAYER = 1
    PRINTER = 2
    PROJECTOR = 3

    _VALUES_TO_NAMES = {
        1: "PLAYER",
        2: "PRINTER",
        3: "PROJECTOR",
    }

    _NAMES_TO_VALUES = {
        "PLAYER": 1,
        "PRINTER": 2,
        "PROJECTOR": 3,
    }


class MusicType(object):
    NONE = 0
    ROCK = 1
    COUNTRY = 2
    POP = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "ROCK",
        2: "COUNTRY",
        3: "POP",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "ROCK": 1,
        "COUNTRY": 2,
        "POP": 3,
    }


class PlayerType(object):
    NONE = 0
    RADIO = 1

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "RADIO",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "RADIO": 1,
    }


class PrinterType(object):
    LASER = 1
    INKJET = 2

    _VALUES_TO_NAMES = {
        1: "LASER",
        2: "INKJET",
    }

    _NAMES_TO_VALUES = {
        "LASER": 1,
        "INKJET": 2,
    }


class OverheatException(TException):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        super(OverheatException, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OverheatException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidArgumentException(TException):
    """
    Attributes:
     - message
     - problemType

    """


    def __init__(self, message=None, problemType=None,):
        super(InvalidArgumentException, self).__setattr__('message', message)
        super(InvalidArgumentException, self).__setattr__('problemType', problemType)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, self.problemType, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        problemType = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    problemType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
            problemType=problemType,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidArgumentException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.problemType is not None:
            oprot.writeFieldBegin('problemType', TType.I32, 2)
            oprot.writeI32(self.problemType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EmptyPrinterException(TException):
    """
    Attributes:
     - message
     - problemType

    """


    def __init__(self, message=None, problemType=None,):
        super(EmptyPrinterException, self).__setattr__('message', message)
        super(EmptyPrinterException, self).__setattr__('problemType', problemType)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.message, self.problemType, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        message = None
        problemType = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    problemType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            message=message,
            problemType=problemType,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EmptyPrinterException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.problemType is not None:
            oprot.writeFieldBegin('problemType', TType.I32, 2)
            oprot.writeI32(self.problemType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeviceInfo(object):
    """
    Attributes:
     - name
     - message

    """


    def __init__(self, name=None, message=None,):
        self.name = name
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.name = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeviceInfo')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.I32, 1)
            oprot.writeI32(self.name)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PlayerDevice(object):
    """
    Attributes:
     - id
     - playerType
     - cdType
     - radioStation
     - volume

    """


    def __init__(self, id=None, playerType=None, cdType=None, radioStation=None, volume=None,):
        self.id = id
        self.playerType = playerType
        self.cdType = cdType
        self.radioStation = radioStation
        self.volume = volume

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.playerType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cdType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.radioStation = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.volume = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PlayerDevice')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.playerType is not None:
            oprot.writeFieldBegin('playerType', TType.I32, 2)
            oprot.writeI32(self.playerType)
            oprot.writeFieldEnd()
        if self.cdType is not None:
            oprot.writeFieldBegin('cdType', TType.I32, 3)
            oprot.writeI32(self.cdType)
            oprot.writeFieldEnd()
        if self.radioStation is not None:
            oprot.writeFieldBegin('radioStation', TType.DOUBLE, 4)
            oprot.writeDouble(self.radioStation)
            oprot.writeFieldEnd()
        if self.volume is not None:
            oprot.writeFieldBegin('volume', TType.DOUBLE, 5)
            oprot.writeDouble(self.volume)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PrinterDevice(object):
    """
    Attributes:
     - id
     - cartridgeLevel
     - printerType
     - sheesOfPaper

    """


    def __init__(self, id=None, cartridgeLevel=None, printerType=None, sheesOfPaper=None,):
        self.id = id
        self.cartridgeLevel = cartridgeLevel
        self.printerType = printerType
        self.sheesOfPaper = sheesOfPaper

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.cartridgeLevel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.printerType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.sheesOfPaper = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PrinterDevice')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.cartridgeLevel is not None:
            oprot.writeFieldBegin('cartridgeLevel', TType.DOUBLE, 2)
            oprot.writeDouble(self.cartridgeLevel)
            oprot.writeFieldEnd()
        if self.printerType is not None:
            oprot.writeFieldBegin('printerType', TType.I32, 3)
            oprot.writeI32(self.printerType)
            oprot.writeFieldEnd()
        if self.sheesOfPaper is not None:
            oprot.writeFieldBegin('sheesOfPaper', TType.I32, 4)
            oprot.writeI32(self.sheesOfPaper)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ProjectorDevice(object):
    """
    Attributes:
     - id
     - lampTemperature

    """


    def __init__(self, id=None, lampTemperature=None,):
        self.id = id
        self.lampTemperature = lampTemperature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.lampTemperature = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProjectorDevice')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.lampTemperature is not None:
            oprot.writeFieldBegin('lampTemperature', TType.DOUBLE, 2)
            oprot.writeDouble(self.lampTemperature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SmarthomeDevices(object):
    """
    Attributes:
     - projectors
     - printers
     - players

    """


    def __init__(self, projectors=None, printers=None, players=None,):
        self.projectors = projectors
        self.printers = printers
        self.players = players

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.projectors = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = ProjectorDevice()
                        _elem5.read(iprot)
                        self.projectors.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.printers = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = PrinterDevice()
                        _elem11.read(iprot)
                        self.printers.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.players = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = PlayerDevice()
                        _elem17.read(iprot)
                        self.players.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SmarthomeDevices')
        if self.projectors is not None:
            oprot.writeFieldBegin('projectors', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.projectors))
            for iter18 in self.projectors:
                iter18.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.printers is not None:
            oprot.writeFieldBegin('printers', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.printers))
            for iter19 in self.printers:
                iter19.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.players is not None:
            oprot.writeFieldBegin('players', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.players))
            for iter20 in self.players:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(OverheatException)
OverheatException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(InvalidArgumentException)
InvalidArgumentException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I32, 'problemType', None, None, ),  # 2
)
all_structs.append(EmptyPrinterException)
EmptyPrinterException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I32, 'problemType', None, None, ),  # 2
)
all_structs.append(DeviceInfo)
DeviceInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'name', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(PlayerDevice)
PlayerDevice.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.I32, 'playerType', None, None, ),  # 2
    (3, TType.I32, 'cdType', None, None, ),  # 3
    (4, TType.DOUBLE, 'radioStation', None, None, ),  # 4
    (5, TType.DOUBLE, 'volume', None, None, ),  # 5
)
all_structs.append(PrinterDevice)
PrinterDevice.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.DOUBLE, 'cartridgeLevel', None, None, ),  # 2
    (3, TType.I32, 'printerType', None, None, ),  # 3
    (4, TType.I32, 'sheesOfPaper', None, None, ),  # 4
)
all_structs.append(ProjectorDevice)
ProjectorDevice.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.DOUBLE, 'lampTemperature', None, None, ),  # 2
)
all_structs.append(SmarthomeDevices)
SmarthomeDevices.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'projectors', (TType.STRUCT, [ProjectorDevice, None], False), None, ),  # 1
    (2, TType.LIST, 'printers', (TType.STRUCT, [PrinterDevice, None], False), None, ),  # 2
    (3, TType.LIST, 'players', (TType.STRUCT, [PlayerDevice, None], False), None, ),  # 3
)
fix_spec(all_structs)
del all_structs
